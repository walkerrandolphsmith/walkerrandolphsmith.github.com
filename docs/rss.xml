<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Walker Randolph Smith]]></title><description><![CDATA[Walker Randolph Smith]]></description><link>http://www.walkerrandolphsmith.com</link><generator>metalsmith-feed</generator><lastBuildDate>Mon, 21 Aug 2017 00:00:54 GMT</lastBuildDate><atom:link href="http://www.walkerrandolphsmith.com/rss.xml" rel="self" type="application/rss+xml"/><author><![CDATA[Walker Randolph Smith]]></author><item><title><![CDATA[Promises]]></title><description><![CDATA[<p>Asynchronous programming in Javascript involves a control flow that is not sequential like what is
expected from most programming languages. This non-sequence nature is due to the result of a function
not being available immediately. In this scenario the program continues execution despite the result of the first
function not returning and the subsequent operations on that result not occurring. Asynchronous code may be a result of
physical limitations causing the reults to not be instant or guaranteed like file IO and network requests.
Asynchronous programming can be a challenging task and it has evolved quite a bit in Javascript since I began programming.
In a few short years I have solved this problem like many other Javascript developers: using callbacks, promises, and now
even <code>async</code> and <code>await</code>. Each of these approaches changes the structure of the asynchronous code as well as the control flow.
For many people seeing the differences between these techniques will actually feel like a stroll down memory lane.</p>]]></description><link>http://www.walkerrandolphsmith.com/promises</link><guid isPermaLink="true">http://www.walkerrandolphsmith.com/promises</guid><dc:creator><![CDATA[Walker Randolph Smith]]></dc:creator><pubDate>Sat, 29 Oct 2016 21:03:24 GMT</pubDate></item><item><title><![CDATA[Array]]></title><description><![CDATA[<p>Sets, lists, and collections are structures I deal with almost everyday when programming. ES5 brought cool  features
like map and reduce, but prior to ES2015 I often used libraries like underscore and lodash to help me operate on arrays.
These libraries and another, Rambda, are still on my radar since they have optimized many of these operations, however
there are a couple common operations  I will cover.</p>]]></description><link>http://www.walkerrandolphsmith.com/array</link><guid isPermaLink="true">http://www.walkerrandolphsmith.com/array</guid><dc:creator><![CDATA[Walker Randolph Smith]]></dc:creator><pubDate>Sat, 29 Oct 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Pair Programming]]></title><description><![CDATA[<p>Over the past two years I have practiced pair programming on a daily basis. Prior to this exposure I was familiar with
the concept of pair programming through reading about extreme programming. I was hopeful it would be beneficial, despite
also hearing negative reviews of the practice. Upon reflection of my experience I have determined that pair programming
is valuable and for many reasons including some I had suspicions of and some in ways I would have never expected.</p>]]></description><link>http://www.walkerrandolphsmith.com/pair-programming</link><guid isPermaLink="true">http://www.walkerrandolphsmith.com/pair-programming</guid><dc:creator><![CDATA[Walker Randolph Smith]]></dc:creator><pubDate>Fri, 28 Oct 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Electron Native Apps]]></title><description><![CDATA[<p>Electron allows for creating cross platform, native applications that run on the Node.js runtime.
Today, native applications can be created with a consistent set of tools including Javascript, HTML, and CSS.
Electron, developed by Github, was orginally known as Atom Shell as it powered the homegrown text editor created at Github, Atom.
Now well known applications such as Slack, Atom, Visual Studio Code, and more have been developed with Electron.
I am going to cover creating a minimal Electron application.</p>]]></description><link>http://www.walkerrandolphsmith.com/electron-native-apps</link><guid isPermaLink="true">http://www.walkerrandolphsmith.com/electron-native-apps</guid><dc:creator><![CDATA[Walker Randolph Smith]]></dc:creator><pubDate>Sat, 22 Oct 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[VersionOne JavaScript SDK]]></title><description><![CDATA[<p>Recently the VersionOne JavaScript SDK received some love and got a major version release.
The SDK allows communication with a VersionOne instance by exposing some of the well documented apis including
 <code>query.v1</code>, <code>rest-1.v1</code>, and <code>metav1</code>. The SDK ultimately makes HTTP requests to a specified VersionOne instance.
In this scenario I will not consider CORS and make all the requests from a server.
This article assumes prior knowledge around Node.js and javascript.
I will cover how to set up a minimal node application that uses an express server and the SDK to make queries to VersionOne.
You can follow along with this git repo <a href="https://github.com/walkerrandolphsmith/sample-v1sdk-app">sample-v1sdk-app</a>.</p>]]></description><link>http://www.walkerrandolphsmith.com/versionone-javascript-sdk</link><guid isPermaLink="true">http://www.walkerrandolphsmith.com/versionone-javascript-sdk</guid><dc:creator><![CDATA[Walker Randolph Smith]]></dc:creator><pubDate>Fri, 21 Oct 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Knockout and Durandal]]></title><description><![CDATA[<p>Single page applications are web applications contained on a single HTML file that are dynamically updated using client side JavaScript in response to user interactions.
This article will discuss creating a SPA using Durandal and Knockout. This technology stack leverages a variation on
the traditional Model View Controller pattern called Model-View-View Model, <strong>MVVM</strong>, which a design pattern for building user interfaces.
The pattern divides the user interface into three major components.
The Models represent the applicationâ€™s stored data. Ajax can be used with server-side code to read and write the stored model data.
The View-Models are JavaScript objects that represent a subset of data and operations on that data required by a specific user interface to render.
The Views are UI components that graphically expose the View-Model data and operations.
Durandal is one of many JavaScript frameworks that leverage this design pattern. One emerging giant is Angular and yesterday it was announced, <a href="http://eisenbergeffect.bluespire.com/angular-and-durandal-converge/">here</a>, on Twitter that Durandal and Angular will converge!</p>]]></description><link>http://www.walkerrandolphsmith.com/knockout-and-durandal</link><guid isPermaLink="true">http://www.walkerrandolphsmith.com/knockout-and-durandal</guid><dc:creator><![CDATA[Walker Randolph Smith]]></dc:creator><pubDate>Tue, 15 Apr 2014 00:00:00 GMT</pubDate></item><item><title><![CDATA[Add Bitbucket Aside to Octopress]]></title><description><![CDATA[<p>Adding public repositories hosted on Bitbucket to your blog is a great idea to showcase your projects.
Checking out how the Github aside works will help, as they are similar.
However, unlike Github, repository names on Bitbucket can have white space, but the URL to a repository is stripped of white space and every letter is converted to lowercase.</p>]]></description><link>http://www.walkerrandolphsmith.com/add-bitbucket-aside-to-octopress</link><guid isPermaLink="true">http://www.walkerrandolphsmith.com/add-bitbucket-aside-to-octopress</guid><dc:creator><![CDATA[Walker Randolph Smith]]></dc:creator><pubDate>Fri, 05 Jul 2013 00:00:00 GMT</pubDate></item></channel></rss>