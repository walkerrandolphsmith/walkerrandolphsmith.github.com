---
title: 'When Integration Matters: Building Webhooks for the Fortune 500'
date: 2025-06-08
tags: ['webhooks', 'automation']
draft: false
excerpt: |
  When you serve the Fortune 500, your software doesn't exist in a vacuum â€” it lives in an ecosystem of platforms, tools, and people, all demanding awareness, context, and control.
  When one story changes, a hundred systems need to know.
  That is the reality we built for: a webhook engine that turns agile events into instant integration signals.
---

> **â€œIntegration isnâ€™t a feature. Itâ€™s infrastructure.â€**  
> That was the mindset shift that drove us to redesign how VersionOne talks to the outside world.

VersionOne powers product planning and agile execution for some of the largest enterprises in the worldâ€”including a significant portion of the Fortune 500. These teams donâ€™t just manage workâ€”they orchestrate massive systems of people, tools, and platforms.

And increasingly, those systems werenâ€™t isolated. They needed to talk to each other.

We needed a way to let our customers knowâ€”immediately and reliablyâ€”when something changed.

So we built **webhook subscriptions**: a flexible, secure, and expressive system for triggering outbound HTTP calls when events happen in VersionOne.

## The Problem: Agile at Enterprise Scale Means Complexity

From CRM to CI/CD, issue tracking to observability, our customers live in a constellation of tools. When something changes in VersionOneâ€”a story moves forward, a defect is resolved, a test failsâ€”itâ€™s often the _start_ of a workflow, not the end.

But prior to this effort, integration meant polling our API or building brittle connectors. That wasnâ€™t scalable. And it certainly wasnâ€™t real-time.

## ğŸ› ï¸ What We Built: A Webhooks System with Enterprise DNA

This wasnâ€™t just a wrapper around a pub/sub model. We designed webhook subscriptions to reflect the complexity of enterprise product teams:

- **Fine-Grained Event Modeling**  
  Webhooks can fire on two core event types:

  - `AssetCreated` â€“ whenever a new object (like a Story, Defect, or Test) is created
  - `AssetChanged` â€“ when any attribute of an object is updated

- **Selective Triggering**  
  Want to be notified for _any_ Story status change? Easy.  
  Want to know _only_ when a Story in _Project A_, owned by _Susan_, changes _status_? Also easy.  
  Thatâ€™s possible thanks to:

  - `attributes` â€“ trigger only on specific fields
  - `filter` + `with` â€“ express rich conditions
  - `userContext` â€“ respect project-level security boundaries

- **Customizable Payloads**  
  Select the specific fields you care about (`select`), and weâ€™ll send a projection of that asset directly in the webhookâ€™s `snapshot`. This keeps payloads clean, relevant, and aligned with your needs.

- **Retry Logic & Delivery Guarantees**  
  Every webhook includes a `sequenceId`, letting external systems re-order events if delivery is out-of-order. And we monitor delivery successâ€”disabling subscriptions after repeated failures to prevent noisy integrations.

- **Authorization & Metadata**  
  Webhooks can be configured with an `authorizationHeader` to meet security requirements. Each payload includes the `instigator`â€”who made the changeâ€”with name, email, role, and more.

## How It Works: From Change to Callback

Letâ€™s walk through a real use case:

**Trigger**: A Story in Project X, owned by Susan, changes its Status.  
**Event Definition**:

```json
{
  "type": "AssetChanged",
  "from": "Story",
  "attributes": ["Status"],
  "filter": ["Scope=$Scope"],
  "with": {
    "$Scope": "Scope:0"
  },
  "userContext": "Member:1002",
  "select": ["Name", "Owners.Name"]
}
```

**Result**: A webhook is fired to the customerâ€™s external system, with the following:

- Who triggered it (Susan)
- What changed (Status from "In Progress" to "Done")
- When (timestamp + sequence)
- Snapshot details (Story name, Owner info)

The customer system can act on that event immediatelyâ€”updating dashboards, triggering workflows, notifying teams, syncing with downstream tools.

## What It Enables

This wasnâ€™t just about writing JSON to a URL. It was about unlocking modern automation inside our customers' ecosystems:

âœ… **Real-time sync** with tools like Jira, GitHub, Jenkins, and ServiceNow

ğŸ”” **Alerting & notifications** in Slack, Teams, or custom UIs

ğŸ”„ **Automated workflows** across QA, release management, and compliance

ğŸ” Improved **traceability**, with system-of-record updates pushed to the right people

## Scaling for the Enterprise

We built webhook subscriptions with constraintsâ€”but with growth in mind:

- Start with 5 active subscriptions per instance, but built for expansion
- Simple, secure HTTP + token delivery model
- Fully self-serve configuration, so teams can define their own rules
- Backed by the same event pipeline infrastructure we trust internally

And critically: we designed this feature with a **contract-first mindset**. We knew customers would build systems around it, so it had to be **predictable**, **observable**, and **future-proof**.

## What We Learned

Expressiveness is essential. Customers donâ€™t want a webhook for everythingâ€”they want control.

Security canâ€™t be bolted on. userContext and authorizationHeader were non-negotiable.

Observability matters. Sequence IDs, retry counts, and clear status codes help teams debug fast.

Integrations are never one-size-fits-all. The more **composable** your system, the more powerful it becomes in the hands of others.

## ğŸš€ Outcomes

âš¡ **Real-time updates** in mission-critical systems

ğŸ”’ **Secure, audit-friendly delivery**

ğŸ’¬ **High customer adoption**, especially among enterprise customers with integration-heavy environments

ğŸ” **Event reuse** across multiple endpointsâ€”from dev workflows to executive reporting

Our customers didnâ€™t just want updatesâ€”they wanted awareness. They wanted VersionOne to be an active participant in their ecosystem, not just a passive database of work items.

Webhook subscriptions made that possible.

## Conclusion

When you serve the Fortune 500, your software doesnâ€™t exist in a vacuum. It lives in an ecosystem of platforms, tools, and peopleâ€”each demanding awareness, context, and control.

By turning events into integrations, and changes into callbacks, we gave customers a new way to connect VersionOne to the rest of their world.

We didnâ€™t just build a feature. We built a foundation.
